#lang racket #| CSC324 Fall 2018: Lab 3 |#

#|
Lab3 SUMMARY:
* Task1: Simple interpreter: infix -> prefix
    * definition of expression (recursion type), operation 
    * input: expression ↑
    * output: the computed value
* Task2: Arithmetic interpreter with an environment
    * input: environment (a hash table),  expression
        * need to use hash-ref
    * output: the computed value

|#

;-------------------------------------------------------------------------------
; ★ Task 1: An arithmetic interpreter ★
;-------------------------------------------------------------------------------

#| Infix Binary Arithmetic Expression Grammar

We define a small grammar as follows:

<expr> = NUMBER | (<expr> <op> <expr>)
<op>   = + | *

NUMBER represents any integer literal in base 10.
Note that this grammar does *not* describe semantically-valid Racket code!
|#

#|
(interpret-arith expr)
  expr: a datum representing an expression generated by the above grammar.

  Returns the value of the given expression (+ and * have their usual mathematical meaning).

  Use //structural pattern matching// on a list of fixed length by using the
  `list` name in the pattern. For example, the define/match clause
  [((list a b c)) b] would match (1 2 3) and evaluate to 2, while the clause
  [((list a 2 c)) c] would match '(1 2 3) but *not* '(2 3 4).

  See https://docs.racket-lang.org/reference/match.html for more information.
|#
(define (interpret-arith expr)
  (cond
    [(number? expr) expr]
    [(equal? (car(cdr expr)) '+) (+ (interpret-arith (car expr)) (interpret-arith (car(cdr(cdr expr)))))]
    [(equal? (car(cdr expr)) '*) (* (interpret-arith (car expr)) (interpret-arith (car(cdr(cdr expr)))))]
    ))
  

      


(module+ test
  (require rackunit)
  
  (test-equal? "Numeric literal" (interpret-arith 3) 3)
  (test-equal? "Simple addition" (interpret-arith '(4 + 5)) 9)
  (test-equal? "Simple multiplication" (interpret-arith '(4 * 5)) 20))


;-------------------------------------------------------------------------------
; ★ Task 2: An arithmetic interpreter with an environment ★
;-------------------------------------------------------------------------------
#| Infix Binary Arithmetic Expression with Identifiers Grammar

We define a small grammar as follows:

<expr> = ID | NUMBER | (<expr> <op> <expr>)
<op>   = + | *

ID represents any valid Racket identifier.
NUMBER represents any integer literal in base 10.
Note that this grammar does *not* describe semantically-valid Racket code!
|#

#|
(interpret-arith-with-ids env expr)
  env: A hash table representing an environment.
       The keys of the hash table are symbols representing identifiers.
  expr: A datum representing a valid expression generated by the above grammar.

  You may assume that all identifiers in `expr` are present in `env`.

  Hint: you should be able to copy-and-paste your implementation of `interpret-arith`
  from above, and just modify it to implement this. Also take a look at the tests.

  Relevant documentation:
    https://docs.racket-lang.org/reference/hashtables.html (lookup `hash-ref`)

  Note: if you want to use define/match here, you need to provide patterns both arguments.
  Since you probably won't need to destructure `env`, you can use a pattern like
  [(_ (whatever-pattern-you-want-for-expr)) ...].
|#
;<expr> = ID | NUMBER | (<expr> <op> <expr>)
;<op>   = + | *

(define (interpret-arith-with-ids env expr)
  (cond
    [(symbol? expr) (hash-ref env expr)]
    [(number? expr) expr]
    [(equal? (car(cdr expr)) '+) (+ (interpret-arith-with-ids env (car expr)) (interpret-arith-with-ids env (car(cdr(cdr expr)))))]
    [(equal? (car(cdr expr)) '*) (* (interpret-arith-with-ids env (car expr)) (interpret-arith-with-ids env (car(cdr(cdr expr)))))]
    ))


(module+ test
  (let ([env (hash 'a 1)])
    (test-equal? "Simple environment {a: 1}"
                 (interpret-arith-with-ids env '(a + 3))
                 4))
  (let ([env (hash 'a 100
                   'b -3)])
    (test-equal? "Simple environment {a: 100, b: -3}"
                 (interpret-arith-with-ids env '(a * b))
                 -300)))
